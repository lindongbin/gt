name: deploy-to-okteto

on:
  schedule:
    - cron: "0 19 * * *"

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:

    - name: Prepare for Deployment
      run: |
        ver=$(curl -sL https://api.github.com/repos/Mrs4s/go-cqhttp/releases?per_page=1 | sed 's/,/\n/g' | grep "tag_name" | head -n 1 | sed 's/:/\n/g' | sed '1d' | sed 's/"//g' | sed 's/ //g')
        curl -sL "https://github.com/Mrs4s/go-cqhttp/releases/download/${ver}/go-cqhttp-${ver}-linux-amd64.tar.gz" | tar -zx go-cqhttp         
        
        cat > device.json << EOF
        {"display":"MIRAI.871355.001","product":"mirai","device":"mirai","board":"mirai","model":"mirai","finger_print":"mamoe/mirai/mirai:10/MIRAI.200122.001/5768199:user/release-keys","boot_id":"e3ddb090-487e-0416-6c1a-bee0c59d45d6","proc_version":"Linux version 3.0.31-5aQF5uaS (android-build@xxx.xxx.xxx.xxx.com)","protocol":1,"imei":"531686398009843"}
        EOF
        
        cat > config.hjson << EOF
        {
            uin: ${{ secrets.CF_QQID_IBM }}
            password: "${{ secrets.CF_QQPW_IBM }}"
            encrypt_password: false
            password_encrypted: ""
            enable_db: false
            access_token: ""
            relogin: {
                enabled: true
                relogin_delay: 3
                max_relogin_times: 0
            }
            _rate_limit: {
                enabled: false
                frequency: 1
                bucket_size: 1
            }
            ignore_invalid_cqcode: false
            force_fragmented: false
            heartbeat_interval: 0
            http_config: {
                enabled: false
                host: 0.0.0.0
                port: 5700
                timeout: 0
                post_urls: {}
            }
            ws_config: {
                enabled: true
                host: 127.0.0.1
                port: 8090
            }
            ws_reverse_servers: [
                {
                    enabled: false
                    reverse_url: ws://you_websocket_universal.server
                    reverse_api_url: ws://you_websocket_api.server
                    reverse_event_url: ws://you_websocket_event.server
                    reverse_reconnect_interval: 3000
                }
            ]
            post_message_format: string
            use_sso_address: true
            debug: false
            log_level: ""
            web_ui: {
                enabled: false
                host: 127.0.0.1
                web_ui_port: 9999
                web_input: false
            }
        }
        EOF
        
        cat > requirements.txt << EOF
        aiohttp
        lxml
        EOF
        
        cat > mirai.py << EOF
        import os, asyncio, aiohttp, random, urllib, json
        from lxml import etree
        async def bdbk(bkmsg):
            try:
                async with aiohttp.ClientSession() as session:
                    bdurl = 'https://baike.baidu.com/item/' + bkmsg
                    headers = {'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0'}
                    async with session.get(url=bdurl, headers = headers) as req:
                        page = await req.text()
                page = etree.HTML(page)
                bkimg = page.xpath('//div[@class="album-wrap"]/img/@src')
                addimg = page.xpath('//div[@class="summary-pic"]/a/img/@src')
                bkimg = bkimg + addimg
                addimg = page.xpath('//img[@class="lazy-img"]/@data-src')
                bkimg = bkimg + addimg
                addimg = page.xpath('//div[@class="pic"]/a/img/@src')
                bkimg = bkimg + addimg
                picnum = len(bkimg)
                if picnum >0:
                    picnum = picnum - 1
                    picnum = random.randint(0, picnum)
                    bkimg = bkimg[picnum].split("?x-bce-process")
                    bkimg = bkimg[0]
                for i in page.xpath('//div[@class="lemma-summary"]/div//sup'):
                    i.getparent().remove(i)
                page = page.xpath('//div[@class="lemma-summary"]/div//text()')
                page = "".join(page).replace('\n', '').replace('\xa0', '')
                if page != '':
                    bkmsg = page + '\nhttps://baike.baidu.com/item/' + urllib.parse.quote(bkmsg)
                    if bkimg:
                        bkmsg = [{"type": "image", "data": {"file": bkimg}}, {"type": "text", "data": {"text": bkmsg}}]
                    else:
                        bkmsg = bkmsg
                    return bkmsg
            except:
                return
        async def ws_group(ws, recv_data):
            if recv_data["sub_type"] == "normal":
                group = recv_data["group_id"]
                message = recv_data["message"]
                bktg = 0
                bkkw = ["百科", "是啥", "啥是", "是谁", "谁是", "是什么", "什么是"]
                for kw in bkkw:
                    if message.find(kw) > -1:
                        bkmsg = message.replace(kw, "")
                        bktg=1
                        break
                if bktg == 1:
                    bkmsg = await bdbk(bkmsg)
                    if bkmsg:
                        sendmsg = {"action": "send_group_msg", "params": {"group_id": group, "message": bkmsg}}
                        await ws.send_json(sendmsg)
                        return
        async def main():
            os.system('./go-cqhttp &')
            retry = True
            while retry == True:
                try:
                    async with aiohttp.ClientSession() as session:
                        async with session.ws_connect("ws://127.0.0.1:8090") as ws:
                            while True:
                                recv_data = await ws.receive()
                                if recv_data.type == aiohttp.WSMsgType.TEXT:
                                    recv_data = json.loads(recv_data.data)
                                    if "post_type" in recv_data:
                                        if recv_data["post_type"] == "message":
                                            await ws_group(ws, recv_data)
                except:
                    await asyncio.sleep(5)
                    retry = True
        asyncio.get_event_loop().run_until_complete(main())
        EOF
        
        cat > Dockerfile << EOF
        FROM python:slim
        COPY . .
        RUN pip install --no-cache-dir -r requirements.txt
        CMD python mirai.py
        EOF
        
        cat > okteto.yml << EOF
        name: mirai
        image: okteto.dev/mirai:golang
        sync:
          - .:/mirai
        EOF
        
    - name: Deploy to Okteto
      run: |
        curl https://get.okteto.com -sSfL | sh
        okteto login --token=${{ secrets.ok_token }}
        okteto build -t registry.cloud.okteto.net/lindongbin/mirai:golang .
        okteto namespace lindongbin
        echo "y" | okteto push
